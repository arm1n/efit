/*!
 * eFit Website
 * An app for financial training in educational environments
 * http://www.e-fit.com
 * @author Armin Pfurtscheller
 * @version 1.0.0
 * Copyright 2017. MIT licensed.
 */
/* global ANGULAR_MODULE, angular, interact */
(function(module, angular) {
  'use strict';

  // --------------------------------------------------
  // Draggable
  // --------------------------------------------------

  //
  // CONTROLLER
  //

  /**
   * @constructor
   */
  var Draggable = function($scope, $element, $attrs) {
    this.$element = $element;
    this.$scope = $scope;
    this.$attrs = $attrs;

    this._body = null;
    this._clone = null;
    this._coordinates = {};
    this._interactable = null;
    this._activeClass = 'active';
    this._itemClass = 'draggable';
    this._disabledClass = 'disabled';

    var me = this;
    this._unwatch = $scope.$watch(
      function(){ return me.disabled; },
      function(disabled) {
        if (disabled) {
          me.$element.addClass(me._disabledClass);
        } else {
          me.$element.removeClass(me._disabledClass);
        }

        me._interactable.draggable({enabled: !disabled});
      }
    );
  };

  Draggable.$inject = ['$scope','$element','$attrs'];

  //
  // PROPERTIES
  //

  /** @var {object} data Connected data for draggable. */
  Draggable.prototype.data = null;

  /** @type {boolean} clone If clone item should be used. */
  Draggable.prototype.clone = false;

  /** @var {boolean} disabled If draggable is disabled. */
  Draggable.prototype.disabled = false;

  /** @type {boolean} clone If clone item should be used. */
  Draggable.prototype.restriction = 'parent';

  //
  // METHODS
  //

  /**
   * Initializes `interact` library on element
   * with all available callbacks for dragging.
   *
   * @public
   * @method $onInit
   * @return {Void}
   */
  Draggable.prototype.$onInit = function() {
    this._body = angular.element(document.body);
    this.$element.addClass(this._itemClass);
    var element = this.$element.get(0);

    this._interactable = interact(element);

    var me = this;
    var options = {
      inertia: true,
      autoScroll: true,
      enabled: !this.disabled,
      onend: this._onEndItem.bind(this),
      onmove: this._onMoveItem.bind(this),
      onstart: this._onStartItem.bind(this),
      snap: {
          targets:[function(x,y,interaction) {
            // 'startCoords' doesn't work here, so
            // we catch initial position once from
            // interaction element and this values
            if (!me._origin) {
              me._origin = {
                x: interaction.startCoords.page.x,
                y: interaction.startCoords.page.y
              };
            }

            // if not dropped, move draggable
            // smoothly back to origin point
            if (!interaction.dropTarget) {
              return {
                x: me._origin.x, // instead of 0
                y: me._origin.y  // instead of 0
              };
            }
          }],
          //offset: 'startCoords',
          endOnly: true
      }
    };

    if (this.clone) {
      angular.extend(options, { manualStart: true });
      this._interactable.on('move', this._onMove.bind(this));
    }

    this._interactable.draggable(options);
    this._interactable.getData = this._getData.bind(this);
  };

  /**
   * Removes event listener and watches.
   *
   * @public
   * @method $onDestroy
   * @return {void}
   */
  Draggable.prototype.$onDestroy = function() {
    this._interactable.unset();
    this._unwatch();
  };

  /**
   * Adds `activeClass` to clone and invokes `onDragStart`.
   *
   * @private
   * @method _onStartItem
   * @return {Void}
   */
  Draggable.prototype._onStartItem = function(event) {
    var target = !this.clone ?
      angular.element(event.target) :
      this._clone;

    target.addClass(this._activeClass);

    this._trigger('onDragStart', {
      $event: event,
      $data: this.data
    });
  };

  /**
   * This performs actual dragging logic with CSS.
   * The method triggers the `onDragMove` callback.
   *
   * @private
   * @method _onMoveItem
   * @return {Void}
   */
  Draggable.prototype._onMoveItem = function(event) {
    var target = !this.clone ?
      angular.element(event.target) :
      this._clone;

    var x = (this._coordinates.x || 0) + event.dx;
    var y = (this._coordinates.y || 0) + event.dy;

    this._translate(target,x,y);

    this._trigger('onDragMove', {
      $event: event,
      $data: this.data
    });
  };

  /**
   * This performs resetting work by removing clone.
   * It invokes always the `onDragEnd` and the `onDrop`
   * callbacks - if dropped on target element.
   *
   * @private
   * @method _onEndItem
   * @return {Void}
   */
  Draggable.prototype._onEndItem = function(event) {
    var dropped = !!event.interaction.dropTarget;

    if (!this.clone) {
      var target = angular.element(event.target);
      target.removeClass(this._activeClass);

      // remove translate for snapping if
      // animating back to origin coords!
      if (!dropped) {
        this._translate(target,0,0);
      }

    } else {
      this._coordinates = {};
      this._clone.remove();
      this._clone = null;
    }

    this._trigger('onDragEnd', {
      $event: event,
      $data: this.data
    });

    if (dropped) {
      this._trigger('onDrop', {
        $event: event,
        $data: this.data
      });
    }
  };

  /**
   * Creates the clone and triggers manual kick-off for `interact`.
   * This is necessary because we want:
   *
   * 1) being able to show clone object
   * 2) being able to have disable control
   *
   * @private
   * @method _onMove
   * @return {Void}
   */
  Draggable.prototype._onMove = function(event) {
    var interactable = event.interactable;
    var interaction = event.interaction;
    var element = event.currentTarget;

    // we've to control `enabled` by our own as we are using the
    // `manualStart` option to create clone - noop if `disabled`
    if (this.disabled) {
      return;
    }

    // create clone if user holds mouse/finger and no interaction
    // is currently started - position absolutely at end of body!
    if (interaction.pointerIsDown && !interaction.interacting()) {
      this._clone = angular.element(element).clone();

      var offsetY = element.clientHeight / 2;
      var offsetX = element.clientWidth / 2;

      var pageY = !!event.touches ?
        event.touches[0].pageY :
        event.pageY;
      var pageX = !!event.touches ?
        event.touches[0].pageX :
        event.pageX;

      this._clone.css({
        left: (pageX - offsetX) + 'px',
        top: (pageY - offsetY) + 'px',
        position: 'absolute'
      });

      this._body.append(this._clone);
      element = this._clone.get(0);
    }

    // invoke 'drag' interaction manually with the target/clone
    interaction.start({ name: 'drag' }, interactable, element);
  };

  /**
   * Retrieves the connected drag object data.
   *
   * @private
   * @method _getData
   * @return {object}
   */
  Draggable.prototype._getData = function() {
    return this.data;
  };

  /**
   * Translates DOM node to given coordinates.
   *
   * @private
   * @method _translate
   * @param object element
   * @param number x
   * @param number y
   * @return {void}
   */
  Draggable.prototype._translate = function(element, x, y) {
    var translate = 'translate('+x+'px,'+y+'px)';

    element.css({
      'webkitTransform': translate,
      'mozTransform': translate,
      'msTransform': translate,
      'oTransform': translate,
      'transform': translate
    });

    this._coordinates.x = x;
    this._coordinates.y = y;
  };

  /**
   * Primitive method for invoking callbacks.
   *
   * @private
   * @method _trigger
   * @return {void}
   */
  Draggable.prototype._trigger = function(method, args) {
    this.$scope.$evalAsync(this[method].bind(this,args));
  };

  //
  // REGISTRY
  //
  angular.module(module).directive('draggable', function(){
    return {
      scope: {
        data: '=?draggableData',
        clone: '=?draggableClone',
        disabled: '=?draggableDisabled',
        onDragStart: '&draggableOnDragStart',
        onDragMove: '&draggableOnDragMove',
        onDragEnd: '&draggableOnDragEnd',
        onDrop: '&draggableOnDrop'
      },
      restrict: 'A',
      controller: Draggable,
      bindToController: true,
      controllerAs: 'draggableController'
    };
  });

  // --------------------------------------------------
  // Dropable
  // --------------------------------------------------

  //
  // CONTROLLER
  //

  /**
   * @constructor
   */
  var Dropable = function($scope, $element, $attrs) {
    this.$element = $element;
    this.$scope = $scope;
    this.$attrs = $attrs;

    this._interactable = null;
    this._enterClass = 'enter';
    this._activeClass = 'active';
    this._itemClass = 'dropable';
    this._acceptClass = 'draggable';
    this._disabledClass = 'disabled';

    var me = this;
    this._unwatch = $scope.$watch(
      function(){ return me.disabled; },
      function(disabled) {
        if (disabled) {
          me.$element.addClass(me._disabledClass);
        } else {
          me.$element.removeClass(me._disabledClass);
        }
      }
    );
  };

  Dropable.$inject = ['$scope','$element','$attrs'];

  //
  // PROPERTIES
  //

  /** @var {boolean} disabled If draggable is disabled. */
  Dropable.prototype.disabled = false;

  //
  // METHODS
  //

  /**
   * Initializes `interact` library on element
   * with all available callbacks for dragging.
   *
   * @public
   * @method $onInit
   * @return {Void}
   */
  Dropable.prototype.$onInit = function() {
    this._body = angular.element(document.body);
    this.$element.addClass(this._itemClass);
    var accept = '.' + this._acceptClass;
    var element = this.$element.get(0);

    this._interactable = interact(element)
      .dropzone({
        accept: accept,
        enabled: !this.disabled,
        ondrop: this._onDrop.bind(this),
        ondragenter: this._onDragEnter.bind(this),
        ondragleave: this._onDragLeave.bind(this),
        ondropactivate: this._onDropActivate.bind(this),
        ondropdeactivate: this._onDropDeactivate.bind(this)
      });
  };

  /**
   * Removes event listener and watches.
   *
   * @public
   * @method $onDestroy
   * @return {void}
   */
  Dropable.prototype.$onDestroy = function() {
    this._interactable.unset();
    this._unwatch();
  };

  /**
   * Removes the active class from element and
   * triggers the `onDropDeactivate` callback.
   *
   * @private
   * @method _onDropDeactivate
   * @return {Void}
   */
  Dropable.prototype._onDropDeactivate = function(event) {
    this.$element.removeClass(this._activeClass);
    var data = event.draggable.getData();

    this._trigger('onDropDeactivate', {
      $event: event,
      $data: data
    });
  };

  /**
   * Applies the active class from element and
   * triggers the `onDropActivate` callback.
   *
   * @private
   * @method _onDropDeactivate
   * @return {Void}
   */
  Dropable.prototype._onDropActivate = function(event) {
    this.$element.addClass(this._activeClass);
    var data = event.draggable.getData();

    this._trigger('onDropActivate', {
      $event: event,
      $data: data
    });
  };

  /**
   * Applies the enter class from element and
   * triggers the `onDragEnter` callback.
   *
   * @private
   * @method _onDropDeactivate
   * @return {Void}
   */
  Dropable.prototype._onDragEnter = function(event) {
    this.$element.addClass(this._enterClass);
    var data = event.draggable.getData();

    this._trigger('onDragEnter', {
      $event: event,
      $data: data
    });
  };

  /**
   * Removes the enter class from element and
   * triggers the `onDragLeave` callback.
   *
   * @private
   * @method _onDropDeactivate
   * @return {Void}
   */
  Dropable.prototype._onDragLeave = function(event) {
    this.$element.removeClass(this._enterClass);
    var data = event.draggable.getData();

    this._trigger('onDragLeave', {
      $event: event,
      $data: data
    });
  };

  /**
   * Removes the enter class from element and
   * triggers the `onDrop` callback with data
   * from the draggable element.
   *
   * @private
   * @method _onDropDeactivate
   * @return {Void}
   */
  Dropable.prototype._onDrop = function(event) {
    this.$element.removeClass(this._enterClass);
    var data = event.draggable.getData();

    this._trigger('onDrop',{
      $event: event,
      $data: data
    });
  };

  /**
   * Primitive method for invoking callbacks.
   *
   * @private
   * @method _trigger
   * @return {void}
   */
  Dropable.prototype._trigger = function(method, args) {
    this.$scope.$evalAsync(this[method].bind(this,args));
  };

  //
  // REGISTRY
  //
  angular.module(module).directive('dropable', function(){
    return {
      scope: {
        disabled: '=?dropableDisabled',
        onDropDeactivate: '&dropableOnDropDeactivate',
        onDropActivate: '&dropableOnDropActivate',
        onDragEnter: '&dropableOnDragEnter',
        onDragLeave: '&dropableOnDragLeave',
        onDrop: '&dropableOnDrop'
      },
      restrict: 'A',
      controller: Dropable,
      bindToController: true,
      controllerAs: 'droppableController'
    };
  });

})(ANGULAR_MODULE, angular);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9kaXJlY3RpdmVzL2RyYWdkcm9wLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYXBwL2RpcmVjdGl2ZXMvZHJhZ2Ryb3AubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEFOR1VMQVJfTU9EVUxFLCBhbmd1bGFyLCBpbnRlcmFjdCAqL1xuKGZ1bmN0aW9uKG1vZHVsZSwgYW5ndWxhcikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRHJhZ2dhYmxlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy9cbiAgLy8gQ09OVFJPTExFUlxuICAvL1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBEcmFnZ2FibGUgPSBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XG4gICAgdGhpcy4kYXR0cnMgPSAkYXR0cnM7XG5cbiAgICB0aGlzLl9ib2R5ID0gbnVsbDtcbiAgICB0aGlzLl9jbG9uZSA9IG51bGw7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMgPSB7fTtcbiAgICB0aGlzLl9pbnRlcmFjdGFibGUgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XG4gICAgdGhpcy5faXRlbUNsYXNzID0gJ2RyYWdnYWJsZSc7XG4gICAgdGhpcy5fZGlzYWJsZWRDbGFzcyA9ICdkaXNhYmxlZCc7XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuX3Vud2F0Y2ggPSAkc2NvcGUuJHdhdGNoKFxuICAgICAgZnVuY3Rpb24oKXvCoHJldHVybiBtZS5kaXNhYmxlZDsgfSxcbiAgICAgIGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgIG1lLiRlbGVtZW50LmFkZENsYXNzKG1lLl9kaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhtZS5fZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5faW50ZXJhY3RhYmxlLmRyYWdnYWJsZSh7ZW5hYmxlZDogIWRpc2FibGVkfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBEcmFnZ2FibGUuJGluamVjdCA9IFsnJHNjb3BlJywnJGVsZW1lbnQnLCckYXR0cnMnXTtcblxuICAvL1xuICAvLyBQUk9QRVJUSUVTXG4gIC8vXG5cbiAgLyoqIEB2YXIge29iamVjdH0gZGF0YSBDb25uZWN0ZWQgZGF0YSBmb3IgZHJhZ2dhYmxlLiAqL1xuICBEcmFnZ2FibGUucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gY2xvbmUgSWYgY2xvbmUgaXRlbSBzaG91bGQgYmUgdXNlZC4gKi9cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5jbG9uZSA9IGZhbHNlO1xuXG4gIC8qKiBAdmFyIHtib29sZWFufSBkaXNhYmxlZCBJZiBkcmFnZ2FibGUgaXMgZGlzYWJsZWQuICovXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKiogQHR5cGUge2Jvb2xlYW59IGNsb25lIElmIGNsb25lIGl0ZW0gc2hvdWxkIGJlIHVzZWQuICovXG4gIERyYWdnYWJsZS5wcm90b3R5cGUucmVzdHJpY3Rpb24gPSAncGFyZW50JztcblxuICAvL1xuICAvLyBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGBpbnRlcmFjdGAgbGlicmFyeSBvbiBlbGVtZW50XG4gICAqIHdpdGggYWxsIGF2YWlsYWJsZSBjYWxsYmFja3MgZm9yIGRyYWdnaW5nLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgJG9uSW5pdFxuICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgKi9cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS4kb25Jbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYm9keSA9IGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMuX2l0ZW1DbGFzcyk7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50LmdldCgwKTtcblxuICAgIHRoaXMuX2ludGVyYWN0YWJsZSA9IGludGVyYWN0KGVsZW1lbnQpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGluZXJ0aWE6IHRydWUsXG4gICAgICBhdXRvU2Nyb2xsOiB0cnVlLFxuICAgICAgZW5hYmxlZDogIXRoaXMuZGlzYWJsZWQsXG4gICAgICBvbmVuZDogdGhpcy5fb25FbmRJdGVtLmJpbmQodGhpcyksXG4gICAgICBvbm1vdmU6IHRoaXMuX29uTW92ZUl0ZW0uYmluZCh0aGlzKSxcbiAgICAgIG9uc3RhcnQ6IHRoaXMuX29uU3RhcnRJdGVtLmJpbmQodGhpcyksXG4gICAgICBzbmFwOiB7XG4gICAgICAgICAgdGFyZ2V0czpbZnVuY3Rpb24oeCx5LGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAnc3RhcnRDb29yZHMnIGRvZXNuJ3Qgd29yayBoZXJlLCBzb1xuICAgICAgICAgICAgLy8gd2UgY2F0Y2ggaW5pdGlhbCBwb3NpdGlvbiBvbmNlIGZyb21cbiAgICAgICAgICAgIC8vIGludGVyYWN0aW9uIGVsZW1lbnQgYW5kIHRoaXMgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIW1lLl9vcmlnaW4pIHtcbiAgICAgICAgICAgICAgbWUuX29yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBpbnRlcmFjdGlvbi5zdGFydENvb3Jkcy5wYWdlLngsXG4gICAgICAgICAgICAgICAgeTogaW50ZXJhY3Rpb24uc3RhcnRDb29yZHMucGFnZS55XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG5vdCBkcm9wcGVkLCBtb3ZlIGRyYWdnYWJsZVxuICAgICAgICAgICAgLy8gc21vb3RobHkgYmFjayB0byBvcmlnaW4gcG9pbnRcbiAgICAgICAgICAgIGlmICghaW50ZXJhY3Rpb24uZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IG1lLl9vcmlnaW4ueCwgLy8gaW5zdGVhZCBvZiAwXG4gICAgICAgICAgICAgICAgeTogbWUuX29yaWdpbi55ICAvLyBpbnN0ZWFkIG9mIDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XSxcbiAgICAgICAgICAvL29mZnNldDogJ3N0YXJ0Q29vcmRzJyxcbiAgICAgICAgICBlbmRPbmx5OiB0cnVlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNsb25lKSB7XG4gICAgICBhbmd1bGFyLmV4dGVuZChvcHRpb25zLCB7IG1hbnVhbFN0YXJ0OiB0cnVlIH0pO1xuICAgICAgdGhpcy5faW50ZXJhY3RhYmxlLm9uKCdtb3ZlJywgdGhpcy5fb25Nb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuX2ludGVyYWN0YWJsZS5kcmFnZ2FibGUob3B0aW9ucyk7XG4gICAgdGhpcy5faW50ZXJhY3RhYmxlLmdldERhdGEgPSB0aGlzLl9nZXREYXRhLmJpbmQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIgYW5kIHdhdGNoZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQG1ldGhvZCAkb25EZXN0cm95XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBEcmFnZ2FibGUucHJvdG90eXBlLiRvbkRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbnRlcmFjdGFibGUudW5zZXQoKTtcbiAgICB0aGlzLl91bndhdGNoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYGFjdGl2ZUNsYXNzYCB0byBjbG9uZSBhbmQgaW52b2tlcyBgb25EcmFnU3RhcnRgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9vblN0YXJ0SXRlbVxuICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgKi9cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fb25TdGFydEl0ZW0gPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSAhdGhpcy5jbG9uZSA/XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoZXZlbnQudGFyZ2V0KSA6XG4gICAgICB0aGlzLl9jbG9uZTtcblxuICAgIHRhcmdldC5hZGRDbGFzcyh0aGlzLl9hY3RpdmVDbGFzcyk7XG5cbiAgICB0aGlzLl90cmlnZ2VyKCdvbkRyYWdTdGFydCcsIHtcbiAgICAgICRldmVudDogZXZlbnQsXG4gICAgICAkZGF0YTogdGhpcy5kYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgcGVyZm9ybXMgYWN0dWFsIGRyYWdnaW5nIGxvZ2ljIHdpdGggQ1NTLlxuICAgKiBUaGUgbWV0aG9kIHRyaWdnZXJzIHRoZSBgb25EcmFnTW92ZWAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX29uTW92ZUl0ZW1cbiAgICogQHJldHVybiB7Vm9pZH1cbiAgICovXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX29uTW92ZUl0ZW0gPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSAhdGhpcy5jbG9uZSA/XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoZXZlbnQudGFyZ2V0KSA6XG4gICAgICB0aGlzLl9jbG9uZTtcblxuICAgIHZhciB4ID0gKHRoaXMuX2Nvb3JkaW5hdGVzLnggfHzCoDApICsgZXZlbnQuZHg7XG4gICAgdmFyIHkgPSAodGhpcy5fY29vcmRpbmF0ZXMueSB8fMKgMCkgKyBldmVudC5keTtcblxuICAgIHRoaXMuX3RyYW5zbGF0ZSh0YXJnZXQseCx5KTtcblxuICAgIHRoaXMuX3RyaWdnZXIoJ29uRHJhZ01vdmUnLCB7XG4gICAgICAkZXZlbnQ6IGV2ZW50LFxuICAgICAgJGRhdGE6IHRoaXMuZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHBlcmZvcm1zIHJlc2V0dGluZyB3b3JrIGJ5IHJlbW92aW5nIGNsb25lLlxuICAgKiBJdCBpbnZva2VzIGFsd2F5cyB0aGUgYG9uRHJhZ0VuZGAgYW5kIHRoZSBgb25Ecm9wYFxuICAgKiBjYWxsYmFja3MgLSBpZiBkcm9wcGVkIG9uIHRhcmdldCBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9vbkVuZEl0ZW1cbiAgICogQHJldHVybiB7Vm9pZH1cbiAgICovXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX29uRW5kSXRlbSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGRyb3BwZWQgPSAhIWV2ZW50LmludGVyYWN0aW9uLmRyb3BUYXJnZXQ7XG5cbiAgICBpZiAoIXRoaXMuY2xvbmUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBhbmd1bGFyLmVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLl9hY3RpdmVDbGFzcyk7XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFuc2xhdGUgZm9yIHNuYXBwaW5nIGlmXG4gICAgICAvLyBhbmltYXRpbmcgYmFjayB0byBvcmlnaW4gY29vcmRzIVxuICAgICAgaWYgKCFkcm9wcGVkKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZSh0YXJnZXQsMCwwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IHt9O1xuICAgICAgdGhpcy5fY2xvbmUucmVtb3ZlKCk7XG4gICAgICB0aGlzLl9jbG9uZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJpZ2dlcignb25EcmFnRW5kJywge1xuICAgICAgJGV2ZW50OiBldmVudCxcbiAgICAgICRkYXRhOiB0aGlzLmRhdGFcbiAgICB9KTtcblxuICAgIGlmIChkcm9wcGVkKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdvbkRyb3AnLCB7XG4gICAgICAgICRldmVudDogZXZlbnQsXG4gICAgICAgICRkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgY2xvbmUgYW5kIHRyaWdnZXJzIG1hbnVhbCBraWNrLW9mZiBmb3IgYGludGVyYWN0YC5cbiAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSB3YW50OlxuICAgKlxuICAgKiAxKSBiZWluZyBhYmxlIHRvIHNob3cgY2xvbmUgb2JqZWN0XG4gICAqIDIpIGJlaW5nIGFibGUgdG8gaGF2ZSBkaXNhYmxlIGNvbnRyb2xcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfb25Nb3ZlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBEcmFnZ2FibGUucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBpbnRlcmFjdGFibGUgPSBldmVudC5pbnRlcmFjdGFibGU7XG4gICAgdmFyIGludGVyYWN0aW9uID0gZXZlbnQuaW50ZXJhY3Rpb247XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXG4gICAgLy8gd2UndmUgdG8gY29udHJvbCBgZW5hYmxlZGAgYnkgb3VyIG93biBhcyB3ZSBhcmUgdXNpbmcgdGhlXG4gICAgLy8gYG1hbnVhbFN0YXJ0YCBvcHRpb24gdG8gY3JlYXRlIGNsb25lIC0gbm9vcCBpZiBgZGlzYWJsZWRgXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgY2xvbmUgaWYgdXNlciBob2xkcyBtb3VzZS9maW5nZXIgYW5kIG5vIGludGVyYWN0aW9uXG4gICAgLy8gaXMgY3VycmVudGx5IHN0YXJ0ZWQgLSBwb3NpdGlvbiBhYnNvbHV0ZWx5IGF0IGVuZCBvZiBib2R5IVxuICAgIGlmIChpbnRlcmFjdGlvbi5wb2ludGVySXNEb3duICYmICFpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpKSB7XG4gICAgICB0aGlzLl9jbG9uZSA9IGFuZ3VsYXIuZWxlbWVudChlbGVtZW50KS5jbG9uZSgpO1xuXG4gICAgICB2YXIgb2Zmc2V0WSA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHZhciBvZmZzZXRYID0gZWxlbWVudC5jbGllbnRXaWR0aCAvIDI7XG5cbiAgICAgIHZhciBwYWdlWSA9ICEhZXZlbnQudG91Y2hlcyA/XG4gICAgICAgIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgOlxuICAgICAgICBldmVudC5wYWdlWTtcbiAgICAgIHZhciBwYWdlWCA9ICEhZXZlbnQudG91Y2hlcyA/XG4gICAgICAgIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggOlxuICAgICAgICBldmVudC5wYWdlWDtcblxuICAgICAgdGhpcy5fY2xvbmUuY3NzKHtcbiAgICAgICAgbGVmdDogKHBhZ2VYIC0gb2Zmc2V0WCkgKyAncHgnLFxuICAgICAgICB0b3A6IChwYWdlWSAtIG9mZnNldFkpICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9ib2R5LmFwcGVuZCh0aGlzLl9jbG9uZSk7XG4gICAgICBlbGVtZW50ID0gdGhpcy5fY2xvbmUuZ2V0KDApO1xuICAgIH1cblxuICAgIC8vIGludm9rZSAnZHJhZycgaW50ZXJhY3Rpb24gbWFudWFsbHkgd2l0aCB0aGUgdGFyZ2V0L2Nsb25lXG4gICAgaW50ZXJhY3Rpb24uc3RhcnQoeyBuYW1lOiAnZHJhZycgfSwgaW50ZXJhY3RhYmxlLCBlbGVtZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjb25uZWN0ZWQgZHJhZyBvYmplY3QgZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfZ2V0RGF0YVxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICBEcmFnZ2FibGUucHJvdG90eXBlLl9nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNsYXRlcyBET00gbm9kZSB0byBnaXZlbiBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfdHJhbnNsYXRlXG4gICAqIEBwYXJhbSBvYmplY3QgZWxlbWVudFxuICAgKiBAcGFyYW0gbnVtYmVyIHhcbiAgICogQHBhcmFtIG51bWJlciB5XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBEcmFnZ2FibGUucHJvdG90eXBlLl90cmFuc2xhdGUgPSBmdW5jdGlvbihlbGVtZW50LCB4LCB5KSB7XG4gICAgdmFyIHRyYW5zbGF0ZSA9ICd0cmFuc2xhdGUoJyt4KydweCwnK3krJ3B4KSc7XG5cbiAgICBlbGVtZW50LmNzcyh7XG4gICAgICAnd2Via2l0VHJhbnNmb3JtJzogdHJhbnNsYXRlLFxuICAgICAgJ21velRyYW5zZm9ybSc6IHRyYW5zbGF0ZSxcbiAgICAgICdtc1RyYW5zZm9ybSc6IHRyYW5zbGF0ZSxcbiAgICAgICdvVHJhbnNmb3JtJzogdHJhbnNsYXRlLFxuICAgICAgJ3RyYW5zZm9ybSc6IHRyYW5zbGF0ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fY29vcmRpbmF0ZXMueCA9IHg7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMueSA9IHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaW1pdGl2ZSBtZXRob2QgZm9yIGludm9raW5nIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfdHJpZ2dlclxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuJHNjb3BlLiRldmFsQXN5bmModGhpc1ttZXRob2RdLmJpbmQodGhpcyxhcmdzKSk7XG4gIH07XG5cbiAgLy9cbiAgLy8gUkVHSVNUUllcbiAgLy9cbiAgYW5ndWxhci5tb2R1bGUobW9kdWxlKS5kaXJlY3RpdmUoJ2RyYWdnYWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGRhdGE6ICc9P2RyYWdnYWJsZURhdGEnLFxuICAgICAgICBjbG9uZTogJz0/ZHJhZ2dhYmxlQ2xvbmUnLFxuICAgICAgICBkaXNhYmxlZDogJz0/ZHJhZ2dhYmxlRGlzYWJsZWQnLFxuICAgICAgICBvbkRyYWdTdGFydDogJyZkcmFnZ2FibGVPbkRyYWdTdGFydCcsXG4gICAgICAgIG9uRHJhZ01vdmU6ICcmZHJhZ2dhYmxlT25EcmFnTW92ZScsXG4gICAgICAgIG9uRHJhZ0VuZDogJyZkcmFnZ2FibGVPbkRyYWdFbmQnLFxuICAgICAgICBvbkRyb3A6ICcmZHJhZ2dhYmxlT25Ecm9wJ1xuICAgICAgfSxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBjb250cm9sbGVyOiBEcmFnZ2FibGUsXG4gICAgICBiaW5kVG9Db250cm9sbGVyOiB0cnVlLFxuICAgICAgY29udHJvbGxlckFzOiAnZHJhZ2dhYmxlQ29udHJvbGxlcidcbiAgICB9O1xuICB9KTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEcm9wYWJsZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vXG4gIC8vIENPTlRST0xMRVJcbiAgLy9cblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgRHJvcGFibGUgPSBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XG4gICAgdGhpcy4kYXR0cnMgPSAkYXR0cnM7XG5cbiAgICB0aGlzLl9pbnRlcmFjdGFibGUgPSBudWxsO1xuICAgIHRoaXMuX2VudGVyQ2xhc3MgPSAnZW50ZXInO1xuICAgIHRoaXMuX2FjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XG4gICAgdGhpcy5faXRlbUNsYXNzID0gJ2Ryb3BhYmxlJztcbiAgICB0aGlzLl9hY2NlcHRDbGFzcyA9ICdkcmFnZ2FibGUnO1xuICAgIHRoaXMuX2Rpc2FibGVkQ2xhc3MgPSAnZGlzYWJsZWQnO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLl91bndhdGNoID0gJHNjb3BlLiR3YXRjaChcbiAgICAgIGZ1bmN0aW9uKCl7wqByZXR1cm4gbWUuZGlzYWJsZWQ7IH0sXG4gICAgICBmdW5jdGlvbihkaXNhYmxlZCkge1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICBtZS4kZWxlbWVudC5hZGRDbGFzcyhtZS5fZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MobWUuX2Rpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBEcm9wYWJsZS4kaW5qZWN0ID0gWyckc2NvcGUnLCckZWxlbWVudCcsJyRhdHRycyddO1xuXG4gIC8vXG4gIC8vIFBST1BFUlRJRVNcbiAgLy9cblxuICAvKiogQHZhciB7Ym9vbGVhbn0gZGlzYWJsZWQgSWYgZHJhZ2dhYmxlIGlzIGRpc2FibGVkLiAqL1xuICBEcm9wYWJsZS5wcm90b3R5cGUuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvL1xuICAvLyBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGBpbnRlcmFjdGAgbGlicmFyeSBvbiBlbGVtZW50XG4gICAqIHdpdGggYWxsIGF2YWlsYWJsZSBjYWxsYmFja3MgZm9yIGRyYWdnaW5nLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgJG9uSW5pdFxuICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgKi9cbiAgRHJvcGFibGUucHJvdG90eXBlLiRvbkluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9ib2R5ID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5faXRlbUNsYXNzKTtcbiAgICB2YXIgYWNjZXB0ID0gJy4nICsgdGhpcy5fYWNjZXB0Q2xhc3M7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50LmdldCgwKTtcblxuICAgIHRoaXMuX2ludGVyYWN0YWJsZSA9IGludGVyYWN0KGVsZW1lbnQpXG4gICAgICAuZHJvcHpvbmUoe1xuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgICAgZW5hYmxlZDogIXRoaXMuZGlzYWJsZWQsXG4gICAgICAgIG9uZHJvcDogdGhpcy5fb25Ecm9wLmJpbmQodGhpcyksXG4gICAgICAgIG9uZHJhZ2VudGVyOiB0aGlzLl9vbkRyYWdFbnRlci5iaW5kKHRoaXMpLFxuICAgICAgICBvbmRyYWdsZWF2ZTogdGhpcy5fb25EcmFnTGVhdmUuYmluZCh0aGlzKSxcbiAgICAgICAgb25kcm9wYWN0aXZhdGU6IHRoaXMuX29uRHJvcEFjdGl2YXRlLmJpbmQodGhpcyksXG4gICAgICAgIG9uZHJvcGRlYWN0aXZhdGU6IHRoaXMuX29uRHJvcERlYWN0aXZhdGUuYmluZCh0aGlzKVxuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIgYW5kIHdhdGNoZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQG1ldGhvZCAkb25EZXN0cm95XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBEcm9wYWJsZS5wcm90b3R5cGUuJG9uRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ludGVyYWN0YWJsZS51bnNldCgpO1xuICAgIHRoaXMuX3Vud2F0Y2goKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgYWN0aXZlIGNsYXNzIGZyb20gZWxlbWVudCBhbmRcbiAgICogdHJpZ2dlcnMgdGhlIGBvbkRyb3BEZWFjdGl2YXRlYCBjYWxsYmFjay5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfb25Ecm9wRGVhY3RpdmF0ZVxuICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgKi9cbiAgRHJvcGFibGUucHJvdG90eXBlLl9vbkRyb3BEZWFjdGl2YXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMuX2FjdGl2ZUNsYXNzKTtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRyYWdnYWJsZS5nZXREYXRhKCk7XG5cbiAgICB0aGlzLl90cmlnZ2VyKCdvbkRyb3BEZWFjdGl2YXRlJywge1xuICAgICAgJGV2ZW50OiBldmVudCxcbiAgICAgICRkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGFjdGl2ZSBjbGFzcyBmcm9tIGVsZW1lbnQgYW5kXG4gICAqIHRyaWdnZXJzIHRoZSBgb25Ecm9wQWN0aXZhdGVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9vbkRyb3BEZWFjdGl2YXRlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBEcm9wYWJsZS5wcm90b3R5cGUuX29uRHJvcEFjdGl2YXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMuX2FjdGl2ZUNsYXNzKTtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRyYWdnYWJsZS5nZXREYXRhKCk7XG5cbiAgICB0aGlzLl90cmlnZ2VyKCdvbkRyb3BBY3RpdmF0ZScsIHtcbiAgICAgICRldmVudDogZXZlbnQsXG4gICAgICAkZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBlbnRlciBjbGFzcyBmcm9tIGVsZW1lbnQgYW5kXG4gICAqIHRyaWdnZXJzIHRoZSBgb25EcmFnRW50ZXJgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9vbkRyb3BEZWFjdGl2YXRlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBEcm9wYWJsZS5wcm90b3R5cGUuX29uRHJhZ0VudGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMuX2VudGVyQ2xhc3MpO1xuICAgIHZhciBkYXRhID0gZXZlbnQuZHJhZ2dhYmxlLmdldERhdGEoKTtcblxuICAgIHRoaXMuX3RyaWdnZXIoJ29uRHJhZ0VudGVyJywge1xuICAgICAgJGV2ZW50OiBldmVudCxcbiAgICAgICRkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVudGVyIGNsYXNzIGZyb20gZWxlbWVudCBhbmRcbiAgICogdHJpZ2dlcnMgdGhlIGBvbkRyYWdMZWF2ZWAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX29uRHJvcERlYWN0aXZhdGVcbiAgICogQHJldHVybiB7Vm9pZH1cbiAgICovXG4gIERyb3BhYmxlLnByb3RvdHlwZS5fb25EcmFnTGVhdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5fZW50ZXJDbGFzcyk7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kcmFnZ2FibGUuZ2V0RGF0YSgpO1xuXG4gICAgdGhpcy5fdHJpZ2dlcignb25EcmFnTGVhdmUnLCB7XG4gICAgICAkZXZlbnQ6IGV2ZW50LFxuICAgICAgJGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZW50ZXIgY2xhc3MgZnJvbSBlbGVtZW50IGFuZFxuICAgKiB0cmlnZ2VycyB0aGUgYG9uRHJvcGAgY2FsbGJhY2sgd2l0aCBkYXRhXG4gICAqIGZyb20gdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9vbkRyb3BEZWFjdGl2YXRlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBEcm9wYWJsZS5wcm90b3R5cGUuX29uRHJvcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLl9lbnRlckNsYXNzKTtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRyYWdnYWJsZS5nZXREYXRhKCk7XG5cbiAgICB0aGlzLl90cmlnZ2VyKCdvbkRyb3AnLHtcbiAgICAgICRldmVudDogZXZlbnQsXG4gICAgICAkZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmltaXRpdmUgbWV0aG9kIGZvciBpbnZva2luZyBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX3RyaWdnZXJcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIERyb3BhYmxlLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuJHNjb3BlLiRldmFsQXN5bmModGhpc1ttZXRob2RdLmJpbmQodGhpcyxhcmdzKSk7XG4gIH07XG5cbiAgLy9cbiAgLy8gUkVHSVNUUllcbiAgLy9cbiAgYW5ndWxhci5tb2R1bGUobW9kdWxlKS5kaXJlY3RpdmUoJ2Ryb3BhYmxlJywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgZGlzYWJsZWQ6ICc9P2Ryb3BhYmxlRGlzYWJsZWQnLFxuICAgICAgICBvbkRyb3BEZWFjdGl2YXRlOiAnJmRyb3BhYmxlT25Ecm9wRGVhY3RpdmF0ZScsXG4gICAgICAgIG9uRHJvcEFjdGl2YXRlOiAnJmRyb3BhYmxlT25Ecm9wQWN0aXZhdGUnLFxuICAgICAgICBvbkRyYWdFbnRlcjogJyZkcm9wYWJsZU9uRHJhZ0VudGVyJyxcbiAgICAgICAgb25EcmFnTGVhdmU6ICcmZHJvcGFibGVPbkRyYWdMZWF2ZScsXG4gICAgICAgIG9uRHJvcDogJyZkcm9wYWJsZU9uRHJvcCdcbiAgICAgIH0sXG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgY29udHJvbGxlcjogRHJvcGFibGUsXG4gICAgICBiaW5kVG9Db250cm9sbGVyOiB0cnVlLFxuICAgICAgY29udHJvbGxlckFzOiAnZHJvcHBhYmxlQ29udHJvbGxlcidcbiAgICB9O1xuICB9KTtcblxufSkoQU5HVUxBUl9NT0RVTEUsIGFuZ3VsYXIpO1xuIl19
