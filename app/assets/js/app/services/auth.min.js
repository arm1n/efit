/*!
 * eFit Website
 * An app for financial training in educational environments
 * http://www.e-fit.com
 * @author Armin Pfurtscheller
 * @version 1.0.0
 * Copyright 2017. MIT licensed.
 */
/* global ANGULAR_MODULE, angular */
(function(module, angular) {
  'use strict';

  //
  // SERVICE
  //

  /**
   * @constructor
   */
  var Auth = function($injector)
    {
      this.$injector = $injector;
    };

  /**
   * @property {Array.<string>} $inject
   */
  Auth.$inject = ['$injector'];

  //
  // METHODS
  //

  /**
   * Sends a POST request to register route and
   * persists retrieved JWT token on success.
   *
   * @public
   * @method signin
   * @param {Object} data Data to submit.
   * @param {string} [firewall='frontend'] firewall
   * @param {Object} [config={}] $http config.
   * @return {Promise}
   */
  Auth.prototype.signup = function(data, firewall, config)
    {
      var $http = this.$injector.get('$http');

      firewall = firewall || 'frontend';
      config = config || {};

      var me = this;
      var successCallback = function(response)
        {
          me._saveToken(response.data);
        };

      var failureCallback = function()
        {
          // noop
        };

      var url = this._getSignupUrl(firewall);

      var promise = $http.post(
        url,
        {
          _username: data.username,
          _password: data.password
        },
        angular.extend(config || {})
      );

      promise.then(
        successCallback,
        failureCallback
      );

      return promise;
    };

  /**
   * Sends a POST request to login route and
   * persists retrieved JWT token on success.
   *
   * @public
   * @method signin
   * @param {Object} data Data to submit.
   * @param {string} [firewall='frontend'] firewall
   * @param {Object} [config={}] $http config.
   * @return {Promise}
   */
  Auth.prototype.signin = function(data, firewall, config)
    {
      var $http = this.$injector.get('$http');

      firewall = firewall || 'frontend';
      config = config || {};

      var me = this;
      var successCallback = function(response)
        {
          me._saveToken(response.data);
        };

      var failureCallback = function()
        {
          // noop
        };

      var url = this._getSigninUrl(firewall);

      var promise = $http.post(
        url,
        {
          _username: data.username,
          _password: data.password
        },
        angular.extend(config || {}, {
          skipAuthorization: true
        })
      );

      promise.then(
        successCallback,
        failureCallback
      );

      return promise;
    };

  /**
   * Destroys JWT token representing user.
   *
   * @public
   * @method logout
   * @param {Object} [config] $http config.
   * @return {Void}
   */
  Auth.prototype.signout = function(config)
    {
      var $http = this.$injector.get('$http');
      var user = this.$injector.get('user');
      var jwt = this.$injector.get('jwt');

      var successCallback = function()
        {
          jwt.removeRefreshToken();
          jwt.removeToken();
          user.unload();
        };

      var failureCallback = function()
        {
          // noop
        };

      return $http.get(
        this._getSignoutUrl(),
        config || {}
      ).then(
        successCallback,
        failureCallback
      );
    };

  /**
   * Sends a POST request to refresh route
   * with saved refresh token from login().
   *
   * @public
   * @method refresh
   * @param {Object} [config] $http config.
   * @return {Promise}
   */
  Auth.prototype.refresh = function(config)
    {
      var $http = this.$injector.get('$http');
      var jwt = this.$injector.get('jwt');

      var me = this;
      var successCallback = function(response)
        {
          me._saveToken(response.data);
          return response;
        };

      var failureCallback = function(rejection)
        {
          return rejection;
        };

      var promise = $http.post(
        this._getRefereshUrl(),
        {
          /* jshint camelcase: false */
          refresh_token: jwt.getRefreshToken()
          /* jshint camelcase: true */
        },
        angular.extend(config || {}, {
          skipAuthorization: true
        })
      );

      return promise.then(
        successCallback,
        failureCallback
      );
    };

  /**
   * Returns decoded JWT token containing
   * user information such as `username`.
   * Note: By default expired tokens are
   * not accepted, set parameter if you
   * want to accept expired tokens too!
   *
   * @public
   * @method getUser
   * @param {boolean} [acceptExpired=false]
   * @return {Object|null}
   */
  Auth.prototype.getUser = function(acceptExpired)
    {
      acceptExpired = acceptExpired || false;

      var jwt = this.$injector.get('jwt');

      var token = jwt.getToken();
      if (!token) {
        return null;
      }

      if (!acceptExpired) {
        if (jwt.isExpired()) {
          return null;
        }
      }

      return jwt.decode(token);
    };

  /**
   * Checks if user has given role provided
   * in `roles` property encoded into JWT.
   *
   * @public
   * @method hasRole
   * @param {string|array} role
   * @return {Promise}
   */
  Auth.prototype.hasRole = function(role)
    {
      var jwt = this.$injector.get('jwt');
      var $q = this.$injector.get('$q');
      var defer = $q.defer();
      var promise = defer.promise;

      var isArray = angular.isArray(role);
      if (isArray && role.length === 0) {
        defer.reject(null);
        return promise;
      }

      if (!role) {
        defer.reject(null);
        return promise;
      }

      // accept expired tokens - we will
      // use refresh() to get new token
      // if current one is invalid now
      var user = this.getUser(true);
      if (user === null) {
        defer.reject(null);
        return promise;
      }

      // primitive method for role check
      var resolveRole = function(user) {
        var roles = user.roles || [];
        if (angular.isString(role)) {
          role = [role];
        }

        var hasRole = false;
        for (var i=0; i<role.length; i++) {
          if (roles.indexOf(role[i]) >= 0) {
            hasRole = true;
            break;
          }
        }

        if (hasRole) {
          defer.resolve();
          return;
        }

        defer.reject();
      };

      // immediately resolve valid tokens
      if (!jwt.isExpired()) {
        resolveRole(user);
        return promise;
      }

      // try to refresh invalid tokens
      var me = this;
      var successCallback = function()
        {
          user = me.getUser();
          resolveRole(user);
        };

      var failureCallback = function()
        {
          defer.reject();
        };

      this.refresh().then(
        successCallback,
        failureCallback
      );

      return promise;
    };

  /**
   * Saves server response containing
   * the `token` and `refresh_token`.
   *
   * @private
   * @method _saveToken
   * @param {object} response
   * @return {void}
   */
  Auth.prototype._saveToken = function(data)
    {
      /* jshint camelcase: false */
      var jwt = this.$injector.get('jwt');

      jwt.setRefreshToken(data.refresh_token);
      jwt.setToken(data.token);
      /* jshint camelcase: true */
    };

  /**
   * Returns endpoint to gather JWT depending on firewall.
   *
   * @private
   * @method _getSigninUrl
   * @param {string} firewall
   * @return {string}
   */
  Auth.prototype._getSigninUrl = function(firewall){
    var API_URL = this.$injector.get('API_URL');

    switch(firewall) {
      case 'backend':
      case 'frontend':
        return API_URL + '/auth/' + firewall + '/signin';
      default:
        throw new Error('Unknown firewall name: ' + firewall);
    }
  };

  /**
   * Returns endpoint to register at given firewall.
   *
   * @private
   * @method _getSignupUrl
   * @param {string} firewall
   * @return {string}
   */
  Auth.prototype._getSignupUrl = function(firewall){
    var API_URL = this.$injector.get('API_URL');

    switch(firewall) {
      case 'frontend':
        return API_URL + '/auth/' + firewall + '/signup';
      case 'backend':
        throw new Error('Not implemented yet!');
      default:
        throw new Error('Unknown firewall name: ' + firewall);
    }
  };

  /**
   * Returns endpoint to refresh the JWT.
   *
   * @private
   * @method _getRefereshUrl
   * @return {string}
   */
  Auth.prototype._getRefereshUrl = function(){
    var API_URL = this.$injector.get('API_URL');

    return API_URL + '/auth/refresh';
  };

  /**
   * Returns endpoint to revoke the JWT.
   *
   * @private
   * @method _getSignoutUrl
   * @param {string} firewall
   * @return {string}
   */
  Auth.prototype._getSignoutUrl = function(){
    var API_URL = this.$injector.get('API_URL');

    return API_URL + '/signout';
  };

  //
  // REGISTRY
  //
  angular.module(module).service('auth', Auth);

})(ANGULAR_MODULE, angular);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zZXJ2aWNlcy9hdXRoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC9zZXJ2aWNlcy9hdXRoLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBBTkdVTEFSX01PRFVMRSwgYW5ndWxhciAqL1xuKGZ1bmN0aW9uKG1vZHVsZSwgYW5ndWxhcikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy9cbiAgLy8gU0VSVklDRVxuICAvL1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBBdXRoID0gZnVuY3Rpb24oJGluamVjdG9yKVxuICAgIHtcbiAgICAgIHRoaXMuJGluamVjdG9yID0gJGluamVjdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59ICRpbmplY3RcbiAgICovXG4gIEF1dGguJGluamVjdCA9IFsnJGluamVjdG9yJ107XG5cbiAgLy9cbiAgLy8gTUVUSE9EU1xuICAvL1xuXG4gIC8qKlxuICAgKiBTZW5kcyBhIFBPU1QgcmVxdWVzdCB0byByZWdpc3RlciByb3V0ZSBhbmRcbiAgICogcGVyc2lzdHMgcmV0cmlldmVkIEpXVCB0b2tlbiBvbiBzdWNjZXNzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2Qgc2lnbmluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgdG8gc3VibWl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpcmV3YWxsPSdmcm9udGVuZCddIGZpcmV3YWxsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnPXt9XSAkaHR0cCBjb25maWcuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBBdXRoLnByb3RvdHlwZS5zaWdudXAgPSBmdW5jdGlvbihkYXRhLCBmaXJld2FsbCwgY29uZmlnKVxuICAgIHtcbiAgICAgIHZhciAkaHR0cCA9IHRoaXMuJGluamVjdG9yLmdldCgnJGh0dHAnKTtcblxuICAgICAgZmlyZXdhbGwgPSBmaXJld2FsbCB8fMKgJ2Zyb250ZW5kJztcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fMKge307XG5cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UpXG4gICAgICAgIHtcbiAgICAgICAgICBtZS5fc2F2ZVRva2VuKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICB2YXIgZmFpbHVyZUNhbGxiYWNrID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9O1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5fZ2V0U2lnbnVwVXJsKGZpcmV3YWxsKTtcblxuICAgICAgdmFyIHByb21pc2UgPSAkaHR0cC5wb3N0KFxuICAgICAgICB1cmwsXG4gICAgICAgIHtcbiAgICAgICAgICBfdXNlcm5hbWU6IGRhdGEudXNlcm5hbWUsXG4gICAgICAgICAgX3Bhc3N3b3JkOiBkYXRhLnBhc3N3b3JkXG4gICAgICAgIH0sXG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGNvbmZpZyB8fCB7fSlcbiAgICAgICk7XG5cbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICBmYWlsdXJlQ2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgUE9TVCByZXF1ZXN0IHRvIGxvZ2luIHJvdXRlIGFuZFxuICAgKiBwZXJzaXN0cyByZXRyaWV2ZWQgSldUIHRva2VuIG9uIHN1Y2Nlc3MuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQG1ldGhvZCBzaWduaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSB0byBzdWJtaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlyZXdhbGw9J2Zyb250ZW5kJ10gZmlyZXdhbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWc9e31dICRodHRwIGNvbmZpZy5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIEF1dGgucHJvdG90eXBlLnNpZ25pbiA9IGZ1bmN0aW9uKGRhdGEsIGZpcmV3YWxsLCBjb25maWcpXG4gICAge1xuICAgICAgdmFyICRodHRwID0gdGhpcy4kaW5qZWN0b3IuZ2V0KCckaHR0cCcpO1xuXG4gICAgICBmaXJld2FsbCA9IGZpcmV3YWxsIHx8wqAnZnJvbnRlbmQnO1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8wqB7fTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSlcbiAgICAgICAge1xuICAgICAgICAgIG1lLl9zYXZlVG9rZW4ocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgIHZhciBmYWlsdXJlQ2FsbGJhY2sgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH07XG5cbiAgICAgIHZhciB1cmwgPSB0aGlzLl9nZXRTaWduaW5VcmwoZmlyZXdhbGwpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9ICRodHRwLnBvc3QoXG4gICAgICAgIHVybCxcbiAgICAgICAge1xuICAgICAgICAgIF91c2VybmFtZTogZGF0YS51c2VybmFtZSxcbiAgICAgICAgICBfcGFzc3dvcmQ6IGRhdGEucGFzc3dvcmRcbiAgICAgICAgfSxcbiAgICAgICAgYW5ndWxhci5leHRlbmQoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgICAgc2tpcEF1dGhvcml6YXRpb246IHRydWVcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICBmYWlsdXJlQ2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIEpXVCB0b2tlbiByZXByZXNlbnRpbmcgdXNlci5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAbWV0aG9kIGxvZ291dFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gJGh0dHAgY29uZmlnLlxuICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgKi9cbiAgQXV0aC5wcm90b3R5cGUuc2lnbm91dCA9IGZ1bmN0aW9uKGNvbmZpZylcbiAgICB7XG4gICAgICB2YXIgJGh0dHAgPSB0aGlzLiRpbmplY3Rvci5nZXQoJyRodHRwJyk7XG4gICAgICB2YXIgdXNlciA9IHRoaXMuJGluamVjdG9yLmdldCgndXNlcicpO1xuICAgICAgdmFyIGp3dCA9IHRoaXMuJGluamVjdG9yLmdldCgnand0Jyk7XG5cbiAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICBqd3QucmVtb3ZlUmVmcmVzaFRva2VuKCk7XG4gICAgICAgICAgand0LnJlbW92ZVRva2VuKCk7XG4gICAgICAgICAgdXNlci51bmxvYWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgdmFyIGZhaWx1cmVDYWxsYmFjayA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfTtcblxuICAgICAgcmV0dXJuICRodHRwLmdldChcbiAgICAgICAgdGhpcy5fZ2V0U2lnbm91dFVybCgpLFxuICAgICAgICBjb25maWcgfHwge31cbiAgICAgICkudGhlbihcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICBmYWlsdXJlQ2FsbGJhY2tcbiAgICAgICk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2VuZHMgYSBQT1NUIHJlcXVlc3QgdG8gcmVmcmVzaCByb3V0ZVxuICAgKiB3aXRoIHNhdmVkIHJlZnJlc2ggdG9rZW4gZnJvbSBsb2dpbigpLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gJGh0dHAgY29uZmlnLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgQXV0aC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGNvbmZpZylcbiAgICB7XG4gICAgICB2YXIgJGh0dHAgPSB0aGlzLiRpbmplY3Rvci5nZXQoJyRodHRwJyk7XG4gICAgICB2YXIgand0ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KCdqd3QnKTtcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSlcbiAgICAgICAge1xuICAgICAgICAgIG1lLl9zYXZlVG9rZW4ocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuXG4gICAgICB2YXIgZmFpbHVyZUNhbGxiYWNrID0gZnVuY3Rpb24ocmVqZWN0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgICAgICAgfTtcblxuICAgICAgdmFyIHByb21pc2UgPSAkaHR0cC5wb3N0KFxuICAgICAgICB0aGlzLl9nZXRSZWZlcmVzaFVybCgpLFxuICAgICAgICB7XG4gICAgICAgICAgLyoganNoaW50IGNhbWVsY2FzZTogZmFsc2UgKi9cbiAgICAgICAgICByZWZyZXNoX3Rva2VuOiBqd3QuZ2V0UmVmcmVzaFRva2VuKClcbiAgICAgICAgICAvKiBqc2hpbnQgY2FtZWxjYXNlOiB0cnVlICovXG4gICAgICAgIH0sXG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICAgIHNraXBBdXRob3JpemF0aW9uOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKFxuICAgICAgICBzdWNjZXNzQ2FsbGJhY2ssXG4gICAgICAgIGZhaWx1cmVDYWxsYmFja1xuICAgICAgKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlY29kZWQgSldUIHRva2VuIGNvbnRhaW5pbmdcbiAgICogdXNlciBpbmZvcm1hdGlvbiBzdWNoIGFzIGB1c2VybmFtZWAuXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQgZXhwaXJlZCB0b2tlbnMgYXJlXG4gICAqIG5vdCBhY2NlcHRlZCwgc2V0IHBhcmFtZXRlciBpZiB5b3VcbiAgICogd2FudCB0byBhY2NlcHQgZXhwaXJlZCB0b2tlbnMgdG9vIVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgZ2V0VXNlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthY2NlcHRFeHBpcmVkPWZhbHNlXVxuICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAgICovXG4gIEF1dGgucHJvdG90eXBlLmdldFVzZXIgPSBmdW5jdGlvbihhY2NlcHRFeHBpcmVkKVxuICAgIHtcbiAgICAgIGFjY2VwdEV4cGlyZWQgPSBhY2NlcHRFeHBpcmVkIHx8wqBmYWxzZTtcblxuICAgICAgdmFyIGp3dCA9IHRoaXMuJGluamVjdG9yLmdldCgnand0Jyk7XG5cbiAgICAgIHZhciB0b2tlbiA9IGp3dC5nZXRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhY2NlcHRFeHBpcmVkKSB7XG4gICAgICAgIGlmIChqd3QuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gand0LmRlY29kZSh0b2tlbik7XG4gICAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHVzZXIgaGFzIGdpdmVuIHJvbGUgcHJvdmlkZWRcbiAgICogaW4gYHJvbGVzYCBwcm9wZXJ0eSBlbmNvZGVkIGludG8gSldULlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgaGFzUm9sZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gcm9sZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgQXV0aC5wcm90b3R5cGUuaGFzUm9sZSA9IGZ1bmN0aW9uKHJvbGUpXG4gICAge1xuICAgICAgdmFyIGp3dCA9IHRoaXMuJGluamVjdG9yLmdldCgnand0Jyk7XG4gICAgICB2YXIgJHEgPSB0aGlzLiRpbmplY3Rvci5nZXQoJyRxJyk7XG4gICAgICB2YXIgZGVmZXIgPSAkcS5kZWZlcigpO1xuICAgICAgdmFyIHByb21pc2UgPSBkZWZlci5wcm9taXNlO1xuXG4gICAgICB2YXIgaXNBcnJheSA9IGFuZ3VsYXIuaXNBcnJheShyb2xlKTtcbiAgICAgIGlmIChpc0FycmF5ICYmIHJvbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlZmVyLnJlamVjdChudWxsKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9sZSkge1xuICAgICAgICBkZWZlci5yZWplY3QobnVsbCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuXG4gICAgICAvLyBhY2NlcHQgZXhwaXJlZCB0b2tlbnMgLSB3ZSB3aWxsXG4gICAgICAvLyB1c2UgcmVmcmVzaCgpIHRvIGdldCBuZXcgdG9rZW5cbiAgICAgIC8vIGlmIGN1cnJlbnQgb25lIGlzIGludmFsaWQgbm93XG4gICAgICB2YXIgdXNlciA9IHRoaXMuZ2V0VXNlcih0cnVlKTtcbiAgICAgIGlmICh1c2VyID09PSBudWxsKSB7XG4gICAgICAgIGRlZmVyLnJlamVjdChudWxsKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHByaW1pdGl2ZSBtZXRob2QgZm9yIHJvbGUgY2hlY2tcbiAgICAgIHZhciByZXNvbHZlUm9sZSA9IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgdmFyIHJvbGVzID0gdXNlci5yb2xlcyB8fMKgW107XG4gICAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHJvbGUpKSB7XG4gICAgICAgICAgcm9sZSA9IFtyb2xlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNSb2xlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxyb2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJvbGVzLmluZGV4T2Yocm9sZVtpXSkgPj0gMCkge1xuICAgICAgICAgICAgaGFzUm9sZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUm9sZSkge1xuICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWZlci5yZWplY3QoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmUgdmFsaWQgdG9rZW5zXG4gICAgICBpZiAoIWp3dC5pc0V4cGlyZWQoKSkge1xuICAgICAgICByZXNvbHZlUm9sZSh1c2VyKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyeSB0byByZWZyZXNoIGludmFsaWQgdG9rZW5zXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgIHVzZXIgPSBtZS5nZXRVc2VyKCk7XG4gICAgICAgICAgcmVzb2x2ZVJvbGUodXNlcik7XG4gICAgICAgIH07XG5cbiAgICAgIHZhciBmYWlsdXJlQ2FsbGJhY2sgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICBkZWZlci5yZWplY3QoKTtcbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5yZWZyZXNoKCkudGhlbihcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgICBmYWlsdXJlQ2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNhdmVzIHNlcnZlciByZXNwb25zZSBjb250YWluaW5nXG4gICAqIHRoZSBgdG9rZW5gIGFuZCBgcmVmcmVzaF90b2tlbmAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX3NhdmVUb2tlblxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIEF1dGgucHJvdG90eXBlLl9zYXZlVG9rZW4gPSBmdW5jdGlvbihkYXRhKVxuICAgIHtcbiAgICAgIC8qIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlICovXG4gICAgICB2YXIgand0ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KCdqd3QnKTtcblxuICAgICAgand0LnNldFJlZnJlc2hUb2tlbihkYXRhLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgand0LnNldFRva2VuKGRhdGEudG9rZW4pO1xuICAgICAgLyoganNoaW50IGNhbWVsY2FzZTogdHJ1ZSAqL1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZW5kcG9pbnQgdG8gZ2F0aGVyIEpXVCBkZXBlbmRpbmcgb24gZmlyZXdhbGwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX2dldFNpZ25pblVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlyZXdhbGxcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQXV0aC5wcm90b3R5cGUuX2dldFNpZ25pblVybCA9IGZ1bmN0aW9uKGZpcmV3YWxsKXtcbiAgICB2YXIgQVBJX1VSTCA9IHRoaXMuJGluamVjdG9yLmdldCgnQVBJX1VSTCcpO1xuXG4gICAgc3dpdGNoKGZpcmV3YWxsKSB7XG4gICAgICBjYXNlICdiYWNrZW5kJzpcbiAgICAgIGNhc2UgJ2Zyb250ZW5kJzpcbiAgICAgICAgcmV0dXJuIEFQSV9VUkwgKyAnL2F1dGgvJyArIGZpcmV3YWxsICsgJy9zaWduaW4nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpcmV3YWxsIG5hbWU6ICcgKyBmaXJld2FsbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZHBvaW50IHRvIHJlZ2lzdGVyIGF0IGdpdmVuIGZpcmV3YWxsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRTaWdudXBVcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpcmV3YWxsXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIEF1dGgucHJvdG90eXBlLl9nZXRTaWdudXBVcmwgPSBmdW5jdGlvbihmaXJld2FsbCl7XG4gICAgdmFyIEFQSV9VUkwgPSB0aGlzLiRpbmplY3Rvci5nZXQoJ0FQSV9VUkwnKTtcblxuICAgIHN3aXRjaChmaXJld2FsbCkge1xuICAgICAgY2FzZSAnZnJvbnRlbmQnOlxuICAgICAgICByZXR1cm4gQVBJX1VSTCArICcvYXV0aC8nICsgZmlyZXdhbGwgKyAnL3NpZ251cCc7XG4gICAgICBjYXNlICdiYWNrZW5kJzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0IScpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpcmV3YWxsIG5hbWU6ICcgKyBmaXJld2FsbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZHBvaW50IHRvIHJlZnJlc2ggdGhlIEpXVC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfZ2V0UmVmZXJlc2hVcmxcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQXV0aC5wcm90b3R5cGUuX2dldFJlZmVyZXNoVXJsID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgQVBJX1VSTCA9IHRoaXMuJGluamVjdG9yLmdldCgnQVBJX1VSTCcpO1xuXG4gICAgcmV0dXJuIEFQSV9VUkwgKyAnL2F1dGgvcmVmcmVzaCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZW5kcG9pbnQgdG8gcmV2b2tlIHRoZSBKV1QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX2dldFNpZ25vdXRVcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpcmV3YWxsXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIEF1dGgucHJvdG90eXBlLl9nZXRTaWdub3V0VXJsID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgQVBJX1VSTCA9IHRoaXMuJGluamVjdG9yLmdldCgnQVBJX1VSTCcpO1xuXG4gICAgcmV0dXJuIEFQSV9VUkwgKyAnL3NpZ25vdXQnO1xuICB9O1xuXG4gIC8vXG4gIC8vIFJFR0lTVFJZXG4gIC8vXG4gIGFuZ3VsYXIubW9kdWxlKG1vZHVsZSkuc2VydmljZSgnYXV0aCcsIEF1dGgpO1xuXG59KShBTkdVTEFSX01PRFVMRSwgYW5ndWxhcik7XG4iXX0=
