/*!
 * eFit Website
 * An app for financial training in educational environments
 * http://www.e-fit.com
 * @author Armin Pfurtscheller
 * @version 1.0.0
 * Copyright 2017. MIT licensed.
 */
/* global ANGULAR_MODULE, angular, Chartist */
(function(module, angular) {
  'use strict';

  //
  // CONTROLLER
  //

  /**
   * @constructor
   */
  var Chart = function($scope, $attrs, $element, $injector) {
    this.$scope = $scope;
    this.$attrs = $attrs;
    this.$element = $element;
    this.$injector = $injector;

    this._chart = null;
  };

  Chart.$inject = ['$scope', '$attrs', '$element', '$injector'];

  //
  // PROPERTIES
  //

  /** @var {array} data Chart data for series. */
  Chart.prototype.data = [];

  //
  // METHODS
  //

  /**
   *
   *
   * @public
   * @method $onInit
   * @return {Void}
   */
  Chart.prototype.$onInit = function()
    {
      var options = this._getOptions();

      var data = {
        labels: this._getLabels(),
        series: this._getData()
      };

      this._render(data, options);
    };

  /**
   * Cleans up everything on destruction.
   *
   * @public
   * @method $onDestroy
   * @return {Void}
   */
  Chart.prototype.$onDestroy = function()
    {
      if (this._chart !== null) {
        this._chart.detach();
        this._chart = null;
      }
    };

  /**
   * Gets data depending on current `task`.
   *
   * @public
   * @method _getData
   * @param {array} data
   * @return int
   */
  Chart.prototype._getData = function() {
    var GROUP_A = this.$injector.get('GROUP_A');
    var GROUP_B = this.$injector.get('GROUP_B');

    var me = this;
    var data = [];

    switch(me.task.type) {
      //case me.$injector.get('TYPE_INTEREST'):
      //case me.$injector.get('TYPE_INFLATION'):
      //case me.$injector.get('TYPE_DIVERSIFICATION'):
      //case me.$injector.get('TYPE_RISK'):
      case me.$injector.get('TYPE_ANCHORING'):

        var map = {};
        map[GROUP_A] = { choice1: 0, choice2: 0, count:0 };
        map[GROUP_B] = { choice1: 0, choice2: 0, count:0 };

        var mapResults = function(result) {
          var group = result.json.group;

          switch (result.json.choice) {
            case 1:
              map[group].choice1++;
              break;
            case 2:
              map[group].choice2++;
              break;
            default:
          }

          map[group].count++;
        };

        angular.forEach(this.results, mapResults);

        var groupA = map[GROUP_A];
        var groupB = map[GROUP_B];

        // series 1
        data.push([
          groupA.choice1 / groupA.count,
          groupB.choice1 / groupB.count
        ]);

        // series 2
        data.push([
          groupA.choice2 / groupA.count,
          groupB.choice2 / groupB.count
        ]);


        break;

      //case me.$injector.get('TYPE_MENTAL_BOOKKEEPING'):
      //case me.$injector.get('TYPE_FRAMING'):
      //case me.$injector.get('TYPE_SAVINGS_TARGET'):
      //case me.$injector.get('TYPE_SAVINGS_SUPPORTED'):
      //case me.$injector.get('TYPE_SELF_COMMITMENT'):
      //case me.$injector.get('TYPE_PROCRASTINATION'):

      default:
    }

    return data;
  };

  /**
   * Gets labels depending on current `task`.
   *
   * @private
   * @method _getLabels
   * @return array
   */
  Chart.prototype._getLabels = function() {
    var i18n = this.$injector.get('i18n');

    switch(this.task.type) {
      case this.$injector.get('TYPE_ANCHORING'):
        return [
          i18n.get('GROUP_A'),
          i18n.get('GROUP_B')
        ];
      default:
        return [];
    }
  };

  /**
   * Gets options depending on current `task`.
   *
   * @private
   * @method _getOptions
   * @return array
   */
  Chart.prototype._getOptions = function() {
    var i18n = this.$injector.get('i18n');

    switch(this.task.type) {
      case this.$injector.get('TYPE_ANCHORING'):
        return {
          seriesBarDistance: 15,
          chartPadding: {
            top: 50,
            left: 0,
            right: 0,
            bottom: 0
          },
          axisY:{
            labelInterpolationFnc: function(value) {
              return (value * 100) + '%';
            },
            ticks: [0, 0.2, 0.4, 0.6, 0.8, 1],
            type: Chartist.FixedScaleAxis,
            high: 1,
            low: 0
          },
          plugins: [
            Chartist.plugins.legend({
              legendNames: [
                i18n.get('Choice 1'),
                i18n.get('Choice 2')
              ]
            })
          ]
        };

      default:
        return {};
    }
  };

  /**
   * Renders chart depending on current `task`.
   *
   * @private
   * @method _render
   * @return array
   */
  Chart.prototype._render = function(data, options) {
    var $timeout = this.$injector.get('$timeout');

    this.$element.addClass('ct-chart');
    var element = this.$element.get(0);

    var me = this;
    var render = function() {
      switch(me.task.type) {
        case me.$injector.get('TYPE_ANCHORING'):
          me._chart = new Chartist.Bar(element, data, options);
          break;
        default:
      }
    };

    $timeout(render, 100);
  };

  //
  // REGISTRY
  //
  angular.module(module).directive('chart', function(){
    return {
      scope: {
        task: '=?chartTask',
        results: '=?chartResults'
      },
      restrict: 'A',
      controller: Chart,
      bindToController: true,
      controllerAs: 'chartController'
    };
  });

})(ANGULAR_MODULE, angular);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9kaXJlY3RpdmVzL2NoYXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcHAvZGlyZWN0aXZlcy9jaGFydC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgQU5HVUxBUl9NT0RVTEUsIGFuZ3VsYXIsIENoYXJ0aXN0ICovXG4oZnVuY3Rpb24obW9kdWxlLCBhbmd1bGFyKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvL1xuICAvLyBDT05UUk9MTEVSXG4gIC8vXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIENoYXJ0ID0gZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRlbGVtZW50LCAkaW5qZWN0b3IpIHtcbiAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcbiAgICB0aGlzLiRhdHRycyA9ICRhdHRycztcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XG5cbiAgICB0aGlzLl9jaGFydCA9IG51bGw7XG4gIH07XG5cbiAgQ2hhcnQuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsICckZWxlbWVudCcsICckaW5qZWN0b3InXTtcblxuICAvL1xuICAvLyBQUk9QRVJUSUVTXG4gIC8vXG5cbiAgLyoqIEB2YXIge2FycmF5fSBkYXRhIENoYXJ0IGRhdGEgZm9yIHNlcmllcy4gKi9cbiAgQ2hhcnQucHJvdG90eXBlLmRhdGEgPSBbXTtcblxuICAvL1xuICAvLyBNRVRIT0RTXG4gIC8vXG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQG1ldGhvZCAkb25Jbml0XG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBDaGFydC5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoKTtcblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGxhYmVsczogdGhpcy5fZ2V0TGFiZWxzKCksXG4gICAgICAgIHNlcmllczogdGhpcy5fZ2V0RGF0YSgpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9yZW5kZXIoZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQ2xlYW5zIHVwIGV2ZXJ5dGhpbmcgb24gZGVzdHJ1Y3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQG1ldGhvZCAkb25EZXN0cm95XG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBDaGFydC5wcm90b3R5cGUuJG9uRGVzdHJveSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICBpZiAodGhpcy5fY2hhcnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY2hhcnQuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2NoYXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGRhdGEgZGVwZW5kaW5nIG9uIGN1cnJlbnQgYHRhc2tgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBtZXRob2QgX2dldERhdGFcbiAgICogQHBhcmFtIHthcnJheX0gZGF0YVxuICAgKiBAcmV0dXJuIGludFxuICAgKi9cbiAgQ2hhcnQucHJvdG90eXBlLl9nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEdST1VQX0EgPSB0aGlzLiRpbmplY3Rvci5nZXQoJ0dST1VQX0EnKTtcbiAgICB2YXIgR1JPVVBfQiA9IHRoaXMuJGluamVjdG9yLmdldCgnR1JPVVBfQicpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgc3dpdGNoKG1lLnRhc2sudHlwZSkge1xuICAgICAgLy9jYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfSU5URVJFU1QnKTpcbiAgICAgIC8vY2FzZSBtZS4kaW5qZWN0b3IuZ2V0KCdUWVBFX0lORkxBVElPTicpOlxuICAgICAgLy9jYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfRElWRVJTSUZJQ0FUSU9OJyk6XG4gICAgICAvL2Nhc2UgbWUuJGluamVjdG9yLmdldCgnVFlQRV9SSVNLJyk6XG4gICAgICBjYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfQU5DSE9SSU5HJyk6XG5cbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBtYXBbR1JPVVBfQV0gPSB7IGNob2ljZTE6IDAsIGNob2ljZTI6IDAsIGNvdW50OjAgfTtcbiAgICAgICAgbWFwW0dST1VQX0JdID0geyBjaG9pY2UxOiAwLCBjaG9pY2UyOiAwLCBjb3VudDowIH07XG5cbiAgICAgICAgdmFyIG1hcFJlc3VsdHMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSByZXN1bHQuanNvbi5ncm91cDtcblxuICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lmpzb24uY2hvaWNlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1hcFtncm91cF0uY2hvaWNlMSsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWFwW2dyb3VwXS5jaG9pY2UyKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXBbZ3JvdXBdLmNvdW50Kys7XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMucmVzdWx0cywgbWFwUmVzdWx0cyk7XG5cbiAgICAgICAgdmFyIGdyb3VwQSA9IG1hcFtHUk9VUF9BXTtcbiAgICAgICAgdmFyIGdyb3VwQiA9IG1hcFtHUk9VUF9CXTtcblxuICAgICAgICAvLyBzZXJpZXMgMVxuICAgICAgICBkYXRhLnB1c2goW1xuICAgICAgICAgIGdyb3VwQS5jaG9pY2UxIC8gZ3JvdXBBLmNvdW50LFxuICAgICAgICAgIGdyb3VwQi5jaG9pY2UxIC8gZ3JvdXBCLmNvdW50XG4gICAgICAgIF0pO1xuXG4gICAgICAgIC8vIHNlcmllcyAyXG4gICAgICAgIGRhdGEucHVzaChbXG4gICAgICAgICAgZ3JvdXBBLmNob2ljZTIgLyBncm91cEEuY291bnQsXG4gICAgICAgICAgZ3JvdXBCLmNob2ljZTIgLyBncm91cEIuY291bnRcbiAgICAgICAgXSk7XG5cblxuICAgICAgICBicmVhaztcblxuICAgICAgLy9jYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfTUVOVEFMX0JPT0tLRUVQSU5HJyk6XG4gICAgICAvL2Nhc2UgbWUuJGluamVjdG9yLmdldCgnVFlQRV9GUkFNSU5HJyk6XG4gICAgICAvL2Nhc2UgbWUuJGluamVjdG9yLmdldCgnVFlQRV9TQVZJTkdTX1RBUkdFVCcpOlxuICAgICAgLy9jYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfU0FWSU5HU19TVVBQT1JURUQnKTpcbiAgICAgIC8vY2FzZSBtZS4kaW5qZWN0b3IuZ2V0KCdUWVBFX1NFTEZfQ09NTUlUTUVOVCcpOlxuICAgICAgLy9jYXNlIG1lLiRpbmplY3Rvci5nZXQoJ1RZUEVfUFJPQ1JBU1RJTkFUSU9OJyk6XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgbGFiZWxzIGRlcGVuZGluZyBvbiBjdXJyZW50IGB0YXNrYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfZ2V0TGFiZWxzXG4gICAqIEByZXR1cm4gYXJyYXlcbiAgICovXG4gIENoYXJ0LnByb3RvdHlwZS5fZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkxOG4gPSB0aGlzLiRpbmplY3Rvci5nZXQoJ2kxOG4nKTtcblxuICAgIHN3aXRjaCh0aGlzLnRhc2sudHlwZSkge1xuICAgICAgY2FzZSB0aGlzLiRpbmplY3Rvci5nZXQoJ1RZUEVfQU5DSE9SSU5HJyk6XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaTE4bi5nZXQoJ0dST1VQX0EnKSxcbiAgICAgICAgICBpMThuLmdldCgnR1JPVVBfQicpXG4gICAgICAgIF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9wdGlvbnMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgYHRhc2tgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9nZXRPcHRpb25zXG4gICAqIEByZXR1cm4gYXJyYXlcbiAgICovXG4gIENoYXJ0LnByb3RvdHlwZS5fZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpMThuID0gdGhpcy4kaW5qZWN0b3IuZ2V0KCdpMThuJyk7XG5cbiAgICBzd2l0Y2godGhpcy50YXNrLnR5cGUpIHtcbiAgICAgIGNhc2UgdGhpcy4kaW5qZWN0b3IuZ2V0KCdUWVBFX0FOQ0hPUklORycpOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlcmllc0JhckRpc3RhbmNlOiAxNSxcbiAgICAgICAgICBjaGFydFBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogNTAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF4aXNZOntcbiAgICAgICAgICAgIGxhYmVsSW50ZXJwb2xhdGlvbkZuYzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAqIDEwMCkgKyAnJSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGlja3M6IFswLCAwLjIsIDAuNCwgMC42LCAwLjgsIDFdLFxuICAgICAgICAgICAgdHlwZTogQ2hhcnRpc3QuRml4ZWRTY2FsZUF4aXMsXG4gICAgICAgICAgICBoaWdoOiAxLFxuICAgICAgICAgICAgbG93OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBDaGFydGlzdC5wbHVnaW5zLmxlZ2VuZCh7XG4gICAgICAgICAgICAgIGxlZ2VuZE5hbWVzOiBbXG4gICAgICAgICAgICAgICAgaTE4bi5nZXQoJ0Nob2ljZSAxJyksXG4gICAgICAgICAgICAgICAgaTE4bi5nZXQoJ0Nob2ljZSAyJylcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgY2hhcnQgZGVwZW5kaW5nIG9uIGN1cnJlbnQgYHRhc2tgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9yZW5kZXJcbiAgICogQHJldHVybiBhcnJheVxuICAgKi9cbiAgQ2hhcnQucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyICR0aW1lb3V0ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KCckdGltZW91dCcpO1xuXG4gICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnY3QtY2hhcnQnKTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnQuZ2V0KDApO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2gobWUudGFzay50eXBlKSB7XG4gICAgICAgIGNhc2UgbWUuJGluamVjdG9yLmdldCgnVFlQRV9BTkNIT1JJTkcnKTpcbiAgICAgICAgICBtZS5fY2hhcnQgPSBuZXcgQ2hhcnRpc3QuQmFyKGVsZW1lbnQsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH07XG5cbiAgICAkdGltZW91dChyZW5kZXIsIDEwMCk7XG4gIH07XG5cbiAgLy9cbiAgLy8gUkVHSVNUUllcbiAgLy9cbiAgYW5ndWxhci5tb2R1bGUobW9kdWxlKS5kaXJlY3RpdmUoJ2NoYXJ0JywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgdGFzazogJz0/Y2hhcnRUYXNrJyxcbiAgICAgICAgcmVzdWx0czogJz0/Y2hhcnRSZXN1bHRzJ1xuICAgICAgfSxcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBjb250cm9sbGVyOiBDaGFydCxcbiAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWUsXG4gICAgICBjb250cm9sbGVyQXM6ICdjaGFydENvbnRyb2xsZXInXG4gICAgfTtcbiAgfSk7XG5cbn0pKEFOR1VMQVJfTU9EVUxFLCBhbmd1bGFyKTtcbiJdfQ==
